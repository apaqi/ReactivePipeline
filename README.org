ReactivePipeline 是轻量级的 一个面向上下文 反应式的 请求处理管道. ❍ ⇢ ❍ ⇢ ❍

Pipeline 的字面意思是管道、流水线。它起到的作用，和一个工厂的流水线类似。原始的 Request 经过 Pipeline ，被一步步加工包装，最后得到对应的Response。 它是ReactivePipeline的核心抽象，用以实现业务逻辑的动态编排。

* Pipeline

Pipeline不属于我们常说的23种设计模式中的一种，它可以看成是责任链模式的一种变体。所谓的管道模式用技术话来说，就是把数据传递给一个任务队列，由任务队列按次序依次对数据进行加工处理。
当业务流程比较复杂时，需要拆分成多个子步骤，且每个子步骤可以自由组合，替换，新增，删除的场景, 即可适用于Pipeline模式.

#+begin_src java
Result block = new DefaultPipeline("example", new UserRequest(List.ofAll(1L, 2L, 3L)), new UserResult())
    .addLast(new ProcessUserStage())
    .addLast(new FetchAdStage())
    .startCalc()
    .block();
#+end_src

这里我们只有代码形式的业务流程编排, 因为在我的认知里, 在常规的业务编排场景里, 配置文件往往显得有点多余和啰嗦.

* Context

假设我们要处理一段业务请求，然后返回一个结果，在返回结果之前，可能还要再写点文件/OSS/ODPS/数据库之类的东西——这是个很通用的场景模型，绝大部分相对耗时的异步服务，都能归类于此.

在实际开发中，事情往往比较繁琐且无趣：request的处理过程，很多时候都会涉及到十几二十个中间变量，它们有一些来自于request直接带进来的信息，有一些是根据request信息拉取的OSS文件，有一些来自于访问RPC拿到的结果，还有更多的是你为了数据过滤、分组、匹配或者单纯就是DTO转换而创建的各种临时list, set, map，它们很可能还分散在不同的类里，你需要将引用到处传来传去。这件事情有多么烦人多么脏且累，相信写过业务代码的朋友都懂。

对于复杂业务，稍微好一点的方式，是把所有的中间数据，全部丢进一个上下文也即Context里。要传递就只用传递这个上下文，要取数据就只从这个上下文里取，这样可以一定程度缓解数据凌乱给你造成的焦躁感，也能有效降低过多引用传递带来的心智负担和工程复杂度, 大部分的复杂业务场景基本都脱离不了Context的影子.

* 响应式自编排

然而事情远没这么简单，随着这个上下文里的东西越来越多，这些数据彼此间的依赖关系越来越复杂，新的麻烦又出现了——先创建谁，后创建谁？这几十个临时变量，有的有直接由上游过滤得到，有的需要对两个set取交集，有的需要根据一个map从另一个list里进行匹配，有的要等很长时间的IO从 OSS 里下载，有的则来自于 mysql 的静态配置。我们需要小心翼翼，确保每一个数据创建的时候，它的上游依赖已经全部准备妥当，不然就只能是 NPE 了。

总之，抽象来看，这所有的中间变量，必然构成一个有向无环图。在写业务逻辑的过程，本质上就是在手动对这个有向无环图进行拓扑排序。示例如下：

#+ATTR_HTML: :width 300px
[[./assets/DAG.png]]

这里我们在Pipeline自然而然的也引入了Context概念, 但是这里的Context并不是直接简单的关于值的存储. 我们定义的是值的求解过程--DataLoader, 用于Pipeline处理过程中的数据求解. DataLoader继承了 src_java[header]{org.reactivestreams.Publisher}
接口. 既充当了数据生产, 同时也兼具数据缓存的能力. 通过reactive的事件传播机制, dataLoader 只需要声明自身数据依赖即可, 剩下的编排上帝会自动完成

[[./assets/自编排.png]]
